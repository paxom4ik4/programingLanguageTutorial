<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="owl/owl.carousel.css"/>
    <link rel="stylesheet" href="styles/index.css">
    <title>Компьютерное тестирование</title>
</head>
<body>
    <header class="header">
        <div class="header-logo">Электронный курс по основам языка программирования C++</div>
        <div class="header-navigation" id="header-navigation">
            <a href="#intro"><div class="nav-item">Введение</div></a>
            <a href="#data-types"><div class="nav-item">Переменные и типы данных</div></a>
            <a href="#condition-operators"><div class="nav-item">Условные операторы</div></a>
            <a href="#loops"><div class="nav-item">Циклы</div></a>
            <a href="#arrays"><div class="nav-item">Массивы</div></a>
            <a href="#functions"><div class="nav-item">Функции</div></a>
            <a href="#pointers"><div class="nav-item">Указатели</div></a>
            <a href="#dynamic-arrays"><div class="nav-item">Динамические массивы</div></a>
        </div>
    </header>
    <a href="helpPage/visualStudioInstruction.html">
            <div class="instruction-link">
            Создание проекта в Visual Studio
        </div>
    </a>
    <section class="introduction" id="intro">
        <div class="owl-carousel">
            <div class="slide-1 slide">
            </div>
            <div class="slide-2 slide">
            </div>
            <div class="slide-3 slide">
            </div>
            <div class="slide-4 slide">
            </div>
        </div>
    </section>
    <section class="data-types topic" id="data-types">
        <div class="topic-heading">Типы данных. Переменные</div>
        <div class="topic-info">
            <div>
                <p>
                    Из школьного курса математики мы все знаем, что такое переменные.
                    В программировании принципы довольно схожи. <br> Переменная — это <strong>«ячейка»</strong> 
                    оперативной памяти компьютера, в которой может храниться какая-либо информация.
                </p>
                <p>
                    В программировании переменная, как и в математике, может иметь название,
                    состоящее из одной латинской буквы, но также может состоять из нескольких символов,
                    целого слова или нескольких слов.
                </p>
            </div>
            <div>  
                <h3>Типы данных</h3> 
                <p>
                    В языке С++ все переменные имеют определенный тип данных. Например, переменная,
                    имеющая целочисленный тип не может содержать ничего кроме целых чисел, а
                    переменная с плавающей точкой — только дробные числа.
                </p>
                <p>
                    Тип данных присваивается переменной при ее объявлении или инициализации.
                    Ниже приведены основные типы данных языка C++, которые нам понадобятся.
                </p>
                <h4>Основные типы данных в C++</h4>
                <ul>
                    <li>int — целочисленный тип данных.</li>
                    <li>float — тип данных с плавающей запятой.</li>
                    <li>double — тип данных с плавающей запятой двойной точности.</li>
                    <li>char — символьный тип данных.</li>
                    <li>bool — логический тип данных.</li>
                </ul>
                <h4>Объявление переменной</h4>
                <p>
                    Объявление переменной в C++ происходит таким образом: 
                    сначала указывается тип данных для этой переменной а
                    затем название этой переменной.
                </p>
                <h3>Пример объявления переменных</h3>
                <div class="code-example">
                    int a; // объявление переменной a целого типа. <br>
                    float b; // объявление переменной b типа данных с плавающей запятой. <br>
                    double c = 14.2; // инициализация переменной типа double. <br>
                    char d = 's'; // инициализация переменной типа char. <br>
                    bool k = true; // инициализация логической переменной k. <br>
                </div>
                <h3>Простой калькулятор на C++</h3>
                <p>
                    Сейчас мы напишем простую программу-калькулятор, которая будет
                    принимать от пользователя два целых числа, а затем определять их сумму:
                </p>
                <div class="code-example calc-example">
                    <pre>
                        #include <iostream> 
                        using namespace std;

                        int main() 
                        { 
                            setlocale(0, ""); 
                            /*7*/ int a, b; // объявление двух переменных a и b целого типа данных. 
                            cout << "Введите первое число: "; 
                            cin >> a; // пользователь присваивает переменной a какое-либо значение. 
                            cout << "Введите второе число: "; 
                            cin >> b; 
                            /*12*/  int c = a + b; // новой переменной c присваиваем значение суммы введенных пользователем данных. 
                            cout << "Сумма чисел = " << c << endl; // вывод ответа. 
                            return 0; 
                        }
                    </pre>
                </div>
                <h3>Разбор кода</h3>
                <p>
                    В 7-й строке кода программы мы объявляем переменные «a» и «b» целого типа int.
                    В следующей строке кода выводится сообщение пользователю, чтобы он ввел с
                    клавиатуры первое число. <br>

                    В 9-й строке стоит еще незнакомая вам конструкция — cin >>.
                    С помощью нее у пользователя запрашивается ввод значения переменной «a» 
                    с клавиатуры. Аналогичным образом задается значение переменной «b». <br>

                    В 12-й строке мы производим инициализацию переменной «c» суммой переменных
                    «a» и «b». Далее находится уже знакомый вам оператор cout, который выводит 
                    на экран строку и значение переменной «c».
                </p>
            </div>
        </div>
    </section>
    <section class="condition-operators topic" id="condition-operators">
        <div class="topic-heading">Условные операторы</div>
        <div class="topic-info">
            <p>
                Встречаются ситуации, когда программе нужно выбрать, какую операцию ей выполнить,
                в зависимости от определенного условия.
                К примеру, мы вводим с клавиатуры целое число. Если это число больше десяти,
                то программа должна выполнить одно действие, иначе — другое. Реализуем этот
                алгоритм на C++ с помощью конструкции ветвления.
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main()
                    {
                        setlocale(0, "");
                        double num;
                    
                        cout << "Введите произвольное число: ";
                        cin >> num;
                    
                        if (num < 10) { // Если введенное число меньше 10.
                            cout << "Это число меньше 10." << endl;
                        } else { // иначе
                            cout << "Это число больше либо равно 10." << endl;
                        }
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Если вы запустите эту программу, то при вводе числа,
                меньшего десяти, будет выводиться соответствующее сообщение.
                Если введенное число окажется большим, либо равным десяти
                — отобразится другое сообщение.
            </p>
            <h3>Оператор if</h3>
            <p>
                Оператор if служит для того, чтобы выполнить какую-либо операцию в том случае,
                когда условие является верным. Условная конструкция в С++ всегда записывается
                в круглых скобках после оператора if.

                Внутри фигурных скобок указывается тело условия. Если условие выполнится,
                то начнется выполнение всех команд, которые находятся между фигурными скобками.
            </p>
            <h3>Пример конструкции ветвления</h3>
            <div class="code-example">
                <pre>
                    if (num < 10) {  // Если введенное число меньше 10.
                        cout << "Это число меньше 10." << endl;
                    } else {  // иначе
                        cout << "Это число больше либо равно 10." << endl;
                    }
                </pre>
            </div>
            <p>
                Здесь говорится: «Если переменная num меньше 10 — вывести соответствующее сообщение.
                Иначе, вывести другое сообщение».
                Усовершенствуем программу так, чтобы она выводила сообщение, о том, что
                переменная num равна десяти:
            </p>
            <div class="code-example">
                <pre>
                    if (num < 10) {  // Если введенное число меньше 10.
                        cout << "Это число меньше 10." << endl;
                    } else if (num == 10) {
                        cout << "Это число равно 10." << endl;
                    } else {  // иначе
                        cout << "Это число больше 10." << endl;
                    }
                </pre>
            </div>
            <p>Здесь мы проверяем три условия:</p>
            <ul>
                <li>Первое — когда введенное число меньше 10-ти</li>
                <li>Второе — когда число равно 10-ти</li>
                <li>И третье — когда число больше десяти</li>
            </ul>
            <p>
                Заметьте, что во втором условии, при проверке равенства, 
                мы используем оператор равенства — ==, а не оператор присваивания, 
                потому что мы не изменяем значение переменной при проверке, а 
                сравниваем ее текущее значение с числом 10.
            </p>
            <ul>
                <li>Если поставить оператор присваивания в условии, то при проверке условия, 
                    значение переменной изменится, после чего это условие выполнится.
                </li>
            </ul>
            <p>
                Каждому оператору if соответствует только один оператор else. Совокупность 
                этих операторов — else if означает, что если не выполнилось предыдущее условие, 
                то проверить данное. Если ни одно из условий не верно, то выполняется тело 
                оператора else.
                Если после оператора if, else или их связки else if должна выполняться 
                только одна команда, то фигурные скобки можно не ставить. Предыдущую программу 
                можно записать следующим образом:
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main()
                    {
                        setlocale(0, "");
                        double num;
                    
                        cout << "Введите произвольное число: ";
                        cin >> num;
                    
                        if (num < 10) // Если введенное число меньше 10.
                            cout << "Это число меньше 10." << endl;
                        else if (num == 10)
                            cout << "Это число равно 10." << endl;
                        else  // иначе
                            cout << "Это число больше 10." << endl;
                    
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Такой метод записи выглядит более компактно. Если при 
                выполнении условия нам требуется выполнить более одной 
                команды, то фигурные скобки необходимы. Например:
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main()
                    {
                        setlocale(0, "");
                        double num;
                        int k;
                    
                        cout << "Введите произвольное число: ";
                        cin >> num;
                    
                        if (num < 10) {  // Если введенное число меньше 10.
                            cout << "Это число меньше 10." << endl;
                            k = 1;
                        } else if (num == 10) {
                            cout << "Это число равно 10." << endl;
                            k = 2;
                        } else {  // иначе
                            cout << "Это число больше 10." << endl;
                            k = 3;
                        }
                    
                        cout << "k = " << k << endl;
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Данная программа проверяет значение переменной num. 
                Если она меньше 10, то присваивает переменной k значение 
                единицы. Если переменная num равна десяти, то присваивает 
                переменной k значение двойки. В противном случае — значение тройки. 
                После выполнения ветвления, значение переменной k выводится на экран.
                
                Хорошенько потренируйтесь, попробуйте придумать свой пример с ветвлением.
                Когда поймете, что поняли эту тему, можете смело приступать к следующему уроку.
            </p>
        </div>
    </section>
    <section class="loops topic" id="loops">
        <div class="topic-heading">Циклы</div>
        <div class="topic-info">
            <p>
                Иногда необходимо повторять одно и то же действие 
                несколько раз подряд. Для этого используют циклы. 
                В этом уроке мы научимся программировать циклы на C++, 
                после чего посчитаем сумму всех чисел от 1 до 1000.
            </p>
            <h3>Цикл For</h3>
            <p>Если мы знаем точное количество действий (итераций) цикла, 
                то можем использовать цикл for. Синтаксис его выглядит 
                примерно так:
            </p>
            <div class="code-example">
                <pre>
                    for (действие до начала цикла;
                    условие продолжения цикла;
                    действия в конце каждой итерации цикла) {
                        инструкция цикла;
                        инструкция цикла 2;
                        инструкция цикла N;
                    }
                </pre>
            </div>
            <p>
                Итерацией цикла называется один проход этого цикла
                Существует частный случай этой записи, который мы сегодня и разберем:
            </p>
            <div class="code-example">
                <pre>
                    for (счетчик = значение; счетчик < значение; шаг цикла) {
                        тело цикла;
                    }
                </pre>
            </div>
            <p>
                <strong>Счетчик цикла</strong> — это переменная, 
                в которой хранится количество проходов данного цикла.
            </p>
            <h4>Описание синтаксиса</h4>
            <ul>
                <ol>Сначала присваивается первоначальное значение счетчику, после чего ставится точка с запятой.</ol>
                <ol>Затем задается конечное значение счетчика цикла. После того, как значение счетчика достигнет указанного предела, цикл завершится. Снова ставим точку с запятой.</ol>
                <ol>Задаем шаг цикла. Шаг цикла — это значение, на которое будет увеличиваться или уменьшаться счетчик цикла при каждом проходе.</ol>
            </ul>
            <h3>Пример кода</h3>
            <p>
                Напишем программу, которая будет считать сумму всех чисел от 1 до 1000.
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main()
                    {
                        int i; // счетчик цикла
                        int sum = 0; // сумма чисел от 1 до 1000.
                        setlocale(0, "");
                        for (i = 1; i <= 1000; i++) // задаем начальное значение 1, конечное 1000 и задаем шаг цикла - 1.
                        {
                            sum = sum + i;
                        }
                        cout << "Сумма чисел от 1 до 1000 = " << sum << endl;         
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Если мы скомпилируем этот код и запустим программу, то она покажет нам ответ: 500500. 
                Это и есть сумма всех целых чисел от 1 до 1000. Если считать это вручную, понадобится
                очень много времени и сил. Цикл выполнил всю рутинную работу за нас.
                Заметьте, что конечное значение счетчика я задал нестрогим неравенством 
                ( <= — меньше либо равно), поскольку, если бы я поставил знак меньше, 
                то цикл произвел бы 999 итераций, т.е. на одну меньше, чем требуется. 
                <br><br>
                Это довольно важный момент, т.к. здесь новички часто допускают ошибки, 
                особенно при работе с массивами (о них будет рассказано в следующем уроке). 
                Значение шага цикла я задал равное единице. i++ — это тоже самое, что и i = i + 1.
                В теле цикла, при каждом проходе программа увеличивает значение переменной 
                sum на i. Еще один очень важный момент — в начале программы я присвоил 
                переменной sum значение нуля. Если бы я этого не сделал, программа вылетела 
                вы в сегфолт.
                <br><br>
                При объявлении переменной без ее инициализации что эта переменная 
                будет хранить «мусор».
                Естественно к мусору мы ничего прибавить не можем. Некоторые компиляторы, 
                такие как gcc, инициализирует переменную нулем при ее объявлении.
            </p>
            <h3>Цикл while</h3>
            <p>
                Когда мы не знаем, сколько итераций должен произвести цикл, 
                нам понадобится цикл while или do...while. Синтаксис цикла 
                while в C++ выглядит следующим образом.
            </p>
            <div class="code-example">
                <pre>
                    while (Условие) {
                        Тело цикла;
                    }
                </pre>
            </div>
            <p>
                Данный цикл будет выполняться, пока условие, указанное в круглых скобках 
                является истиной. Решим ту же задачу с помощью цикла while. Хотя здесь мы 
                точно знаем, сколько итераций должен выполнить цикл, очень часто бывают 
                ситуации, когда это значение неизвестно.
                <br><br>
                Ниже приведен исходный код программы, считающей сумму всех целых чисел от 1 до 1000.
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main()
                    {
                        setlocale(0, "");
                        int i = 0; // инициализируем счетчик цикла.
                        int sum = 0; // инициализируем счетчик суммы.
                        while (i < 1000)
                        {
                            i++;
                            sum += i;
                        }
                        cout << "Сумма чисел от 1 до 1000 = " << sum << endl; 
                        return 0;
                    }
                </pre>
            </div>
            <p>
                После компиляции программа выдаст результат, аналогичный результату
                работы предыдущей программы. Но поясним несколько важных моментов.
                Я задал строгое неравенство в условии цикла и инициализировал
                счетчик i нулем, так как в цикле while происходит на одну итерацию
                больше, потому он будет выполняться, до тех пор, пока значение
                счетчика перестает удовлетворять условию, но данная итерация 
                все равно выполнится. Если бы мы поставили нестрогое неравенство, 
                то цикл бы закончился, когда переменная i стала бы равна 1001 и 
                выполнилось бы на одну итерацию больше.
                <br><br>
                Теперь давайте рассмотрим по порядку исходный код нашей программы. 
                Сначала мы инициализируем счетчик цикла и переменную, хранящую сумму чисел.
                <br><br>
                В данном случае мы обязательно должны присвоить счетчику цикла 
                какое-либо значение, т.к. в предыдущей программе мы это значение 
                присваивали внутри цикла for, здесь же, если мы не инициализируем 
                счетчик цикла, то в него попадет «мусор» и компилятор в лучшем случае 
                выдаст нам ошибку, а в худшем, если программа соберется — сегфолт 
                практически неизбежен.
                <br><br>
                Затем мы описываем условие цикла — «пока переменная i меньше 1000 — 
                выполняй цикл». При каждой итерации цикла значение переменной-счетчика 
                i увеличивается на единицу внутри цикла.
                <br><br>
                Когда выполнится 1000 итераций цикла, счетчик станет равным 999 
                и следующая итерация уже не выполнится, поскольку 1000 не меньше 
                1000. Выражение sum += i является укороченной записью sum = sum + i.
                <br><br>
                После окончания выполнения цикла, выводим сообщение с ответом.
            </p>
            <h3>Цикл do while</h3>
            <p>
                Цикл do while очень похож на цикл while. Единственное их различие 
                в том, что при выполнении цикла do while один проход цикла будет 
                выполнен независимо от условия. Решение задачи на поиск суммы 
                чисел от 1 до 1000, с применением цикла do while.
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main ()
                    {
                        setlocale(0, "");
                        int i = 0; // инициализируем счетчик цикла.
                        int sum = 0; // инициализируем счетчик суммы.
                        do {// выполняем цикл.
                            i++;
                            sum += i;
                        } while (i < 1000); // пока выполняется условие.
                        cout << "Сумма чисел от 1 до 1000 = " << sum << endl;
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Принципиального отличия нет, но если присвоить переменной i 
                значение, большее, чем 1000, то цикл все равно выполнит хотя бы один проход.
                <br><br>
                Попрактикуйтесь, поэкспериментируйте над собственными примерами задач. 
                Циклы — очень важная вещь, поэтому им стоит уделить побольше внимания. 
                Когда поймете, как работают циклы — можете смело переходить к изучению 
                следующего урока.
            </p>
        </div>
    </section>
    <section class="topic arrays" id="arrays">
        <div class="topic-heading">Массивы</div>
        <div class="topic-info">
            <p>
                Сегодня мы с поговорим о массивах. Вы уже знаете, что переменная — 
                это ячейка в памяти компьютера, где может храниться одно единственное 
                значение. Массив — это область памяти, где могут последовательно 
                храниться несколько значений.
                <br><br>
                Возьмем группу студентов из десяти человек. У каждого из них есть 
                фамилия. Создавать отдельную переменную для каждого студента — не 
                рационально. Создадим массив, в котором будут храниться фамилии 
                всех студентов.
            </p>
            <h3>Пример инициализации массива</h3>
            <div class="code-example">
                <pre>
                    string students[10] = {
                        "Иванов", "Петров", "Сидоров",
                        "Ахмедов", "Ерошкин", "Выхин",
                        "Андеев", "Вин Дизель", "Картошкин", "Чубайс"
                    };
                </pre>
            </div>
            <h3>Описание синтаксиса</h3>
            <p>
                Массив создается почти так же, как и обычная переменная. Для хранения 
                десяти фамилий нам нужен массив, состоящий из 10 элементов. Количество 
                элементов массива задается при его объявлении и заключается в 
                квадратные скобки.
                <br><br>
                Чтобы описать элементы массива сразу при его создании, можно 
                использовать фигурные скобки. В фигурных скобках значения 
                элементов массива перечисляются через запятую. В конце закрывающей 
                фигурной скобки ставится точка с запятой.
                <br><br>
                Попробуем вывести наш массив на экран с помощью оператора cout.
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    #include <string>
                    
                    int main()    
                    {
                        std::string students[10] = {
                            "Иванов", "Петров", "Сидоров",
                            "Ахмедов", "Ерошкин", "Выхин",
                            "Андеев", "Вин Дизель", "Картошкин", "Чубайс"
                        };
                        std::cout << students << std::endl; // Пытаемся вывести весь массив непосредственно
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Скомпилируйте этот код и посмотрите, на результат работы программы. 
                Готово? А теперь запустите программу еще раз и сравните с предыдущим 
                результатом. В моей операционной системе вывод был следующим:
            </p>
            <ul>
                <li>Первый вывод: 0x7ffff8b85820</li>
                <li>Второй вывод: 0x7fff7a335f90</li>
                <li>Третий вывод: 0x7ffff847eb40</li>
            </ul>
            <p>
                Мы видим, что выводится адрес этого массива в оперативной памяти, а 
                никакие не «Иванов» и «Петров».
                <br><br>
                Дело в том, что при создании переменной, ей выделяется определенное 
                место в памяти. Если мы объявляем переменную типа int, то на машинном 
                уровне она описывается двумя параметрами — ее адресом и размером хранимых данных.
                <br><br>
                Массивы в памяти хранятся таким же образом. Массив типа int из 10 элементов 
                описывается с помощью адреса его первого элемента и количества байт, которое 
                может вместить этот массив. Если для хранения одного целого числа выделяется 
                4 байта, то для массива из десяти целых чисел будет выделено 40 байт.
                <br><br>
                Так почему же, при повторном запуске программы, адреса различаются? 
                Это сделано для защиты от атак переполнения буфера. Такая технология 
                называется рандомизацией адресного пространства и реализована в 
                большинстве популярных ОС.
                <br><br>
                Попробуем вывести первый элемент массива — фамилию студента Иванова.
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    #include <string>
                    
                    int main()
                    {    
                        std::string students[10] = {
                            "Иванов", "Петров", "Сидоров",
                            "Ахмедов", "Ерошкин", "Выхин",
                            "Андеев", "Вин Дизель", "Картошкин", "Чубайс"
                        };
                        std::cout << students[0] <<  std::endl;
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Смотрим, компилируем, запускаем. Убедились, что вывелся именно «Иванов». 
                Заметьте, что нумерация элементов массива в C++ начинается с нуля. 
                Следовательно, фамилия первого студента находится в students[0], а 
                фамилия последнего — в students[9].
                <br><br>
                В большинстве языков программирования нумерация элементов массива 
                также начинается с нуля.
                <br><br>
                Попробуем вывести список всех студентов. Но сначала подумаем, а 
                что если бы вместо группы из десяти студентов, была бы кафедра 
                их ста, факультет из тысячи, или даже весь университет? Ну не 
                будем же мы писать десятки тысяч строк с cout?
                <br><br>
                Конечно же нет! Мы возьмем на вооружение циклы, о которых был написан предыдущий урок.
            </p>
            <h3>Вывод элементов массива через цикл</h3>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    #include <string>
                    
                    int main()
                    {
                        std::string students[10] = {
                            "Иванов", "Петров", "Сидоров",
                            "Ахмедов", "Ерошкин", "Выхин",
                            "Андеев", "Вин Дизель", "Картошкин", "Чубайс"
                        };  
                        for (int i = 0; i < 10; i++) {
                            std::cout << students[i] << std::endl;
                        }
                    
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Если бы нам пришлось выводить массив из нескольких тысяч фамилий, 
                то мы бы просто увеличили конечное значение счетчика цикла — 
                строку for (...; i < 10; ...) заменили на for (...; i < 10000; ...).
                <br><br>
                Заметьте что счетчик нашего цикла начинается с нуля, 
                а заканчивается девяткой. Если вместо оператора строгого 
                неравенства — i < 10 использовать оператор «меньше, либо 
                равно» — i <= 10, то на последней итерации программа 
                обратится к несуществующему элементу массива — students[10]. 
                Это может привести к ошибкам сегментации и аварийному 
                завершению программы. Будьте внимательны — подобные ошибки 
                бывает сложно отловить.
                <br><br>
                Массив, как и любую переменную можно не заполнять значениями при объявлении.
            </p>
            <h3>Объявление массива без инициализации</h3>
            <div class="code-example">
                <pre>
                    string students[10];
                    // или
                    string teachers[5];
                </pre>
            </div>
            <p>
                Элементы такого массива обычно содержат в себе «мусор» из выделенной, 
                но еще не инициализированной, памяти. Некоторые компиляторы, такие 
                как GCC, заполняют все элементы массива нулями при его создании.
                <br><br>
                При создании статического массива, для указания его размера может 
                использоваться только константа. Размер выделяемой памяти определяется 
                на этапе компиляции и не может изменяться в процессе выполнения.
            </p>
            <div class="code-example">
                <pre>
                    int n;
                    cin >> n;
                    string students[n]; /* Неверно */
                </pre>
            </div>
            <p>
                Выделение памяти в процессе выполнения возможно при работе 
                с динамическими массивами. Но о них немного позже.
                <br><br>
                Заполним с клавиатуры пустой массив из 10 элементов.
            </p>
            <h4>Заполнение массива с клавиатуры</h4>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    #include <string>
                    
                    using std::cout;
                    using std::cin;
                    using std::endl;
                    
                    int main()
                    {    
                            int arr[10];
                    
                            // Заполняем массив с клавиатуры
                            for (int i = 0; i < 10; i++) {
                                cout << "[" << i + 1 << "]" << ": ";
                                cin >> arr[i];
                            }
                    
                            // И выводим заполненный массив.
                            cout << "\nВаш массив: ";
                    
                            for (int i = 0; i < 10; ++i) {
                                cout << arr[i] << " ";
                            }
                    
                            cout << endl;
                    
                            return 0;
                    }
                </pre>
            </div>
            <p>Скомпилируем эту программу и проверим ее работу.</p>
            <img src="assets/array-example.png" alt="array-example">
            <p>
                Если у вас возникают проблемы при компиляции исходников 
                из уроков — внимательно прочитайте ошибку компилятора, 
                попробуйте проанализировать и исправить ее.
            </p>
            <p>
                Массивы — очень важная вещь в программировании.
            </p>
        </div>
    </section>
    <section class="topic function" id="functions">
        <div class="topic-heading">Функции</div>
        <div class="topic-info">
            <p>
                Сегодня мы поговорим о функциях в C++. Очень часто в 
                программировании необходимо выполнять одни и те же 
                действия. Например, мы хотим выводить пользователю 
                сообщения об ошибке в разных местах программы, если 
                он ввел неверное значение. без функций это выглядело 
                бы так:
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    #include <string>
                    
                    using namespace std;
                    
                    int main()
                    {    
                        string valid_pass = "qwerty123";
                        string user_pass;
                        cout << "Введите пароль: ";
                        getline(cin, user_pass);
                        if (user_pass == valid_pass) {
                            cout << "Доступ разрешен." << endl;
                        } else {
                            cout << "Неверный пароль!" << endl;
                        }
                        return 0;    
                    }
                </pre>
            </div>
            <p>А вот аналогичный пример с функцией:</p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    #include <string>
                    
                    using namespace std;
                    
                    void check_pass (string password)
                    {
                        string valid_pass = "qwerty123";
                        if (password == valid_pass) {
                            cout << "Доступ разрешен." << endl;
                        } else {
                            cout << "Неверный пароль!" << endl;
                        }
                    }
                    
                    int main()
                    {    
                        string user_pass;
                        cout << "Введите пароль: ";
                        getline (cin, user_pass);
                        check_pass (user_pass);
                        return 0;
                    }
                </pre>
            </div>
            <p>
                По сути, после компиляции не будет никакой разницы для 
                процессора, как для первого кода, так и для второго. 
                Но ведь такую проверку пароля мы можем делать в нашей 
                программе довольно много раз. И тогда получается копипаста 
                и код становится нечитаемым. Функции — один из самых 
                важных компонентов языка C++.
            </p>
            <ul>
                <li>Любая функция имеет тип, также, как и любая переменная.</li>
                <li>
                    Функция может возвращать значение, тип которого в 
                    большинстве случаев аналогично типу самой функции.
                </li>
                <li>
                    Если функция не возвращает никакого значения, то 
                    она должна иметь тип void (такие функции иногда 
                    называют процедурами)
                </li>
                <li>
                    При объявлении функции, после ее типа должно находиться 
                    имя функции и две круглые скобки — открывающая и 
                    закрывающая, внутри которых могут находиться один 
                    или несколько аргументов функции, которых также может не быть вообще.
                </li>
                <li>
                    после списка аргументов функции ставится открывающая фигурная 
                    скобка, после которой находится само тело функции.
                </li>
                <li>В конце тела функции обязательно ставится закрывающая фигурная скобка.</li>
            </ul>
            <h3>Пример построения функции</h3>
            <div class="code-example">
                <pre>
                    #include <iostream>     
                    using namespace std;
                    
                    void function_name ()
                    {
                        cout << "Hello, world" << endl;
                    }
                    
                    int main()
                    {
                        function_name(); // Вызов функции
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Перед вами тривиальная программа, Hello, world, только реализованная с 
                использованием функций.
                <br><br>
                Если мы хотим вывести «Hello, world» где-то еще, нам просто нужно 
                вызвать соответствующую функцию. В данном случае это делается так: 
                function_name();. Вызов функции имеет вид имени функции с 
                последующими круглыми скобками. Эти скобки могут быть пустыми, 
                если функция не имеет аргументов. Если же аргументы в самой 
                функции есть, их необходимо указать в круглых скобках.
                <br><br>
                Также существует такое понятие, как параметры функции по умолчанию. 
                Такие параметры можно не указывать при вызове функции, т.к. они 
                примут значение по умолчанию, указанно после знака присваивания 
                после данного параметра и списке всех параметров функции.
                <br><br>
                В предыдущих примерах мы использовали функции типа void, которые 
                не возвращают никакого значения. Как многие уже догадались, 
                оператор return используется для возвращения вычисляемого функцией значения.
                <br><br>
                Рассмотрим пример функции, возвращающей значение на примере проверки пароля.
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    #include <string>
                    
                    using namespace std;
                    
                    string check_pass (string password)
                    {
                        string valid_pass = "qwerty123";
                        string error_message;
                        if (password == valid_pass) {
                            error_message = "Доступ разрешен.";
                        } else {
                            error_message = "Неверный пароль!";
                        }
                        return error_message;
                    }
                    
                    int main()
                    {    
                        string user_pass;
                        cout << "Введите пароль: ";
                        getline (cin, user_pass);
                        string error_msg = check_pass (user_pass);
                        cout << error_msg << endl;
                        return 0;
                    }
                </pre>
            </div>
            <p>
                В данном случае функция check_pass имеет тип string, следовательно 
                она будет возвращать только значение типа string, иными словами 
                говоря строку. Давайте рассмотрим алгоритм работы этой программы.
                <br><br>
                Самой первой выполняется функция main(), которая должна 
                присутствовать в каждой программе. Теперь мы объявляем 
                переменную user_pass типа string, затем выводим пользователю 
                сообщение «Введите пароль», который после ввода попадает
                в строку user_pass. А вот дальше начинает работать наша
                собственная функция check_pass().
                <br><br>
                В качестве аргумента этой функции передается строка, 
                введенная пользователем.
                <br><br>
                Аргумент функции — это, если сказать простым языком 
                переменные или константы вызывающей функции, которые 
                будет использовать вызываемая функция.
                <br><br>
                При объявлении функций создается формальный параметр, 
                имя которого может отличаться от параметра, передаваемого 
                при вызове этой функции. Но типы формальных параметров и 
                передаваемых функии аргументов в большинстве случаев должны 
                быть аналогичны.
                <br><br>
                После того, как произошел вызов функции check_pass(), начинает 
                работать данная функция. Если функцию нигде не вызвать, то этот 
                код будет проигнорирован программой. Итак, мы передали в 
                качестве аргумента строку, которую ввел пользователь.
                <br><br>
                Теперь эта строка в полном распоряжении функции (хочу обратить 
                Ваше внимание на то, что переменные и константы, объявленные 
                в разных функциях независимы друг от друга, они даже могут 
                иметь одинаковые имена. В следующих уроках я расскажу о том, 
                что такое область видимости, локальные и глобальные переменные).
                <br><br>
                Теперь мы проверяем, правильный ли пароль ввел пользователь 
                или нет. если пользователь ввел правильный пароль, присваиваем 
                переменной error_message соответствующее значение. если нет, 
                то сообщение об ошибке.
                <br><br>
                После этой проверки мы возвращаем переменную error_message. 
                На этом работа нашей функции закончена. А теперь, в функции 
                main(), то значение, которое возвратила наша функция мы 
                присваиваем переменной error_msg и выводим это значение 
                (строку) на экран терминала.
                <br><br>
                Также, можно организовать повторный ввод пароля с помощью 
                рекурсии (о ней мы еще поговорим). Если объяснять вкратце, 
                рекурсия — это когда функция вызывает сама себя. 
                <br><br>
                Смотрите еще один пример:
            </p>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    #include <string>
                    
                    using namespace std;
                    
                    bool password_is_valid (string password)
                    {
                            string valid_pass = "qwerty123";
                            if (valid_pass == password)
                                    return true;
                            else
                                    return false;
                    }
                    
                    void get_pass ()
                    {
                            string user_pass;
                            cout << "Введите пароль: ";
                            getline(cin, user_pass);
                            if (!password_is_valid(user_pass)) {
                                    cout << "Неверный пароль!" << endl;
                                    get_pass (); // Здесь делаем рекурсию
                            } else {
                                    cout << "Доступ разрешен." << endl;
                            }
                    }
                    
                    int main()
                    {
                            get_pass ();
                            return 0;
                    }
                </pre>
            </div>
            <p>
                Функции очень сильно облегчают работу программисту и намного 
                повышают читаемость и понятность кода, в том числе и для 
                самого разработчика (не удивляйтесь этому, т. к. если вы 
                откроете код, написанный вами полгода назад,не сразу поймете 
                соль, поверьте на слово).

                Не расстраивайтесь, если не сразу поймете все аспекты функций 
                в C++, т. к. это довольно сложная тема и мы еще будем разбирать
                примеры с функциями в следующих уроках.

                Совет: не бойтесь экспериментировать, это очень хорошая 
                практика, а после прочтения данной статьи порешайте 
                элементарные задачи, но с использованием функций. 
                Это будет очень полезно для вас.
            </p>
        </div>
    </section>
    <section class="topic pointers" id="pointers">
        <div class="topic-heading">Указатели</div>
        <div class="topic-info">
            <p>
                При выполнении любой программы, все необходимые для ее работы данные 
                должныбыть загружены в оперативную память компьютера. Для обращения 
                к переменным, находящимся в памяти, используются специальные адреса,
                которые записываются в шестнадцатеричном виде, например 0x100 или 0x200.
                <br><br>
                Если переменных в памяти потребуется слишком большое количество, которое 
                не сможет вместить в себя сама аппаратная часть, произойдет перегрузка 
                системы или её зависание.
                <br><br>
                Если мы объявляем переменные статично, так как мы делали в предыдущих 
                уроках, они остаются в памяти до того момента, как программа завершит 
                свою работу, а после чего уничтожаются.
                <br><br>
                Такой подход может быть приемлем в простых примерах и несложных 
                программах, которые не требуют большого количества ресурсов. 
                Если же наш проект является огромным программным комплексом с 
                высоким функционалом, объявлять таким образом переменные, естественно, 
                было бы довольно не умно.
                <br><br>
                Можете себе представить, если бы небезызвестная Battlefield 3 
                использовала такой метод работы с данными? В таком случае, 
                самым заядлым геймерам пришлось бы перезагружать свои высоконагруженные 
                системы кнопкой reset после нескольких секунд работы игры.
                <br><br>
                Дело в том, что играя в тот же Battlefield, геймер в каждый новый 
                момент времени видит различные объекты на экране монитора, например 
                сейчас я стреляю во врага, а через долю секунды он уже падает убитым, 
                создавая вокруг себя множество спецэффектов, таких как пыль, тени, и т.п.
                <br><br>
                Естественно, все это занимает какое-то место в оперативной памяти компьютера. 
                Если не уничтожать неиспользуемые объекты, очень скоро они заполнят весь 
                объем ресурсов ПК.
                <br><br>
                По этим причинам, в большинстве языков, в том числе и C/C++, имеется 
                понятие указателя. Указатель — это переменная, хранящая в себе адрес 
                ячейки оперативной памяти, например 0x100.
                <br><br>
                Мы можем обращаться, например к массиву данных через указатель, который 
                будет содержать адрес начала диапазона ячеек памяти, хранящих этот массив.
                <br><br>
                После того, как этот массив станет не нужен для выполнения остальной 
                части программы, мы просто освободим память по адресу этого указателя, 
                и она вновь станет доступно для других переменных.
                <br><br>
                Ниже приведен конкретный пример обращения к переменным через указатель и напрямую.
            </p>
            <h3>Пример использования статических переменных</h3>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main()
                    {
                        int a; // Объявление статической переменной
                        int b = 5; // Инициализация статической переменной b
                    
                        a = 10;
                        b = a + b;
                        cout << "b is " << b << endl;
                        return 0;
                    }
                </pre>
            </div>
            <h3>Пример использования динамических переменных</h3>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main()
                    {
                        int *a = new int; // Объявление указателя для переменной типа int
                        int *b = new int(5); // Инициализация указателя
                    
                        *a = 10;
                        *b = *a + *b;
                    
                        cout << "b is " << *b << endl;
                    
                        delete b;
                        delete a;
                    
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Синтаксис первого примера вам уже должен быть знаком. Мы объявляем/инициализируем 
                статичные переменные a и b, после чего выполняем различные операции напрямую с ними.
                <br><br>
                Во втором примере мы оперируем динамическими переменными посредством указателей. 
                Рассмотрим общий синтаксис указателей в C++.
                <br><br>
                Выделение памяти осуществляется с помощью оператора new и имеет вид: тип_данных 
                *имя_указателя = new тип_данных;, например int *a = new int;. После удачного 
                выполнения такой операции, в оперативной памяти компьютера происходит выделение 
                диапазона ячеек, необходимого для хранения переменной типа int.
                <br><br>
                Логично предположить, что для разных типов данных выделяется разное количество 
                памяти. Следует быть особенно осторожным при работе с памятью, потому что именно 
                ошибки программы, вызванные утечкой памяти, являются одними из самых трудно 
                находимых. На отладку программы в поисках одной ничтожной ошибки, может уйти 
                час, день, неделя, в зависимости от упорности разработчика и объема кода.
                <br><br>
                Инициализация значения, находящегося по адресу указателя выполняется схожим 
                образом, только в конце ставятся круглые скобки с нужным значением: тип данных 
                *имя_указателя = new тип_данных(значение). В нашем примере это int *b = new int(5).
                <br><br>
                Для того, чтобы получить адрес в памяти, на который ссылается указатель, 
                используется имя переменной-указателя с префиксом &. перед ним (не путать 
                со знаком ссылки в C++).
                <br><br>
                Например, чтобы вывести на экран адрес ячейки памяти, на который ссылается 
                указатель b во втором примере, мы пишем cout << "Address of b is " << &b << endl;. 
                В моей системе, я получил значение 0x1aba030. У вас оно может быть другим, 
                потому что адреса в оперативной памяти распределяются таким образом, чтобы 
                максимально уменьшить фрагментацию. Поскольку, в любой системе список запущенных 
                процессов, а также объем и разрядность памяти могут отличаться, система сама 
                распределяет данные для обеспечения минимальной фрагментации.
                <br><br>
                Для того, чтобы получить значение, которое находится по адресу, на который 
                ссылается указатель, используется префикс *. Данная операция называется 
                разыменованием указателя.
                <br><br>
                Во втором примере мы выводим на экран значение, которое находится в ячейке 
                памяти (у меня это 0x1aba030): cout << "b is " << *b << endl; . В этом случае 
                необходимо использовать знак *.
                <br><br>
                Чтобы изменить значение, находящееся по адресу, на который ссылается указатель, 
                нужно также использовать звездочку, например, как во втором примере — *b = *a + *b;.
            </p>
            <ul>
                <li>Когда мы оперируем данными, то используем знак *</li>
                <li>Когда мы оперируем адресами, то используем знак &</li>
            </ul>
            <p>
                В этих вещах очень часто возникают недопонимания, и кстати, не только у 
                новичков. Многие из тех, кто начинал программировать с того же php, 
                также часто испытывают подобную путаницу при работе с памятью.
                <br><br>
                Для того, чтобы освободить память, выделенную оператором new, используется оператор delete.
            </p>
            <h3>Пример освобождения памяти</h3>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                    
                    int main()
                    {
                        // Выделение памяти
                        int *a = new int;
                        int *b = new int;
                        float *c = new float;
                    
                        // ... Любые действия программы
                    
                        // Освобождение выделенной памяти
                        delete c;
                        delete b;
                        delete a;
                    
                        return 0;
                    }
                </pre>
            </div>
            <p>!!! При использовании оператора delete для указателя, знак * не используется.</p>
        </div>
    </section>
    <section class="topic dynamic-arrays" id="dynamic-arrays">
        <div class="topic-heading">Динамические массивы</div>
        <div class="topic-info">
            <p>
                В одном из предыдущих уроков мы разобрали понятие массива. 
                При объявлении, мы задавали массиву определенный постоянный 
                размер. Возможно, кто-то из читателей пробовал делать так:
            </p>
            <div class="code-example">
                <pre>
                    int n = 10;
                    int arr[n];
                </pre>
            </div>
            <p>
                Но, как уже было сказано — при объявлении статического массива, его размером 
                должна являться числовая константа, а не переменная. В большинстве случаев, 
                целесообразно выделять определенное количество памяти для массива, значение 
                которого изначально неизвестно.
                <br><br>
                Например, необходимо создать динамический массив из N элементов, где 
                значение N задается пользователем. В предыдущем уроке мы учились выделять
                память для переменных, используя указатели. Выделение памяти для динамического 
                массива имеет аналогичный принцип.
            </p>
            <h3>Создание динамического массива</h3>
            <div class="code-example">
                <pre>
                    #include <iostream>
                    using namespace std;
                        
                    int main()
                    {
                        int num; // размер массива
                        cout << "Enter integer value: ";
                        cin >> num; // получение от пользователя размера массива
                    
                        int *p_darr = new int[num]; // Выделение памяти для массива
                        for (int i = 0; i < num; i++) {
                            // Заполнение массива и вывод значений его элементов
                            p_darr[i] = i;
                            cout << "Value of " << i << " element is " << p_darr[i] << endl;
                        }
                        delete [] p_darr; // очистка памяти
                        return 0;
                    }
                </pre>
            </div>
            <p>
                Синтаксис выделения памяти для массива имеет вид указатель = new тип[размер]. 
                В качестве размера массива может выступать любое целое положительное значение.
            </p>
        </div>
    </section>
    <footer class="footer">
        <div class="footer-info">
            В данном небольшом курсе, мы познакомились с языком программирования С++. 
            <br><br>
            Познакомились с его основами, разобрали такие темы как: Переменные и типы данных, 
            Условные операторы, Циклы, Массивы, Функции, Указатели, Динамические массивы
            <br><br>
            Если у вас есть какие-то вопросы или пожелания можете написать мне в telegram: @paxom4ik4
            <br><br>
            Вполне возможно дополение данного курса второй частью. Успехов в обучении
        </div>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="owl/owl.carousel.js"></script>
    <script src="scripts/index.js"></script>
</body>
</html>